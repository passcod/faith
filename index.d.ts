/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Agent {
  constructor(options?: AgentOptions | undefined | null)
  addCookie(url: string, cookie: string): void
  getCookie(url: string): string | null
  stats(): AgentStats
}

export declare class AgentStats {
  requestsSent: number
  responsesReceived: number
}

export declare class FaithResponse {
  get headers(): Array<[string, string]>
  get ok(): boolean
get peer(): { address?: string; certificate?: Buffer }
get redirected(): boolean
get status(): number
get statusText(): string
get type(): string
get url(): string
get version(): string
/** Check if the response body has been disturbed (read) */
get bodyUsed(): boolean
/** Get the response body as a ReadableStream */
get body(): ReadableStream<Buffer> | null
/**
 * Get response body as bytes
 *
 * This may use up to 2x the amount of memory that the response body takes
 * when the Response is cloned() and will create a full copy of the data.
 */
bytes(): Async<Buffer>
/** Convert response body to text (UTF-8) */
text(): Async<string>
/** Parse response body as JSON */
json(): Async<any>
/**
 * Create a clone of the response
 *
 * Specially, this doesn't set the disturbed flag, so that `body()` or other such
 * methods can work afterwards. However, it will throw if the body has already
 * been read from.
 *
 * Clones will cache in memory the section of the response body that is read
 * from one clone and not yet consumed by all others. In the worst case, you can
 * end up with a copy of the entire response body if you end up not consuming one
 * of the clones.
 */
clone(): FaithResponse
}

export interface AgentDnsOptions {
  system?: boolean
  overrides?: Array<DnsOverride>
}

export interface AgentHttp3Options {
  congestion?: Http3Congestion
  maxIdleTimeout?: number
}

export interface AgentOptions {
  cookies?: boolean
  dns?: AgentDnsOptions
  headers?: Array<Header>
  http3?: AgentHttp3Options
  pool?: AgentPoolOptions
  redirect?: Redirect
  timeout?: AgentTimeoutOptions
  tls?: AgentTlsOptions
  userAgent?: string
}

export interface AgentPoolOptions {
  idleTimeout?: number
  maxIdlePerHost?: number
}

export interface AgentTimeoutOptions {
  connect?: number
  read?: number
  total?: number
}

export interface AgentTlsOptions {
  earlyData?: boolean
  identity?: Buffer | string
  required?: boolean
}

export declare const enum CredentialsOption {
  Omit = 'omit',
  SameOrigin = 'same-origin',
  Include = 'include'
}

export interface DnsOverride {
  domain: string
  addresses: Array<string>
}

export declare const enum DuplexOption {
  Half = 'half'
}

export declare function errorCodes(): Array<string>

export const FAITH_VERSION: string

export declare const enum FaithErrorKind {
  Aborted = 'Aborted',
  AddressParse = 'AddressParse',
  BodyStream = 'BodyStream',
  InvalidHeader = 'InvalidHeader',
  InvalidMethod = 'InvalidMethod',
  InvalidUrl = 'InvalidUrl',
  JsonParse = 'JsonParse',
  Network = 'Network',
  PemParse = 'PemParse',
  Redirect = 'Redirect',
  ResponseAlreadyDisturbed = 'ResponseAlreadyDisturbed',
  ResponseBodyNotAvailable = 'ResponseBodyNotAvailable',
  RuntimeThread = 'RuntimeThread',
  Timeout = 'Timeout',
  Utf8Parse = 'Utf8Parse'
}

export declare function faithFetch(url: string, options: FaithOptionsAndBody, signal?: AbortSignal | undefined | null): Async<FaithResponse>

export interface FaithOptionsAndBody {
  method?: string
  headers?: Array<[string, string]>
  body?: string | Buffer | Uint8Array
  timeout?: number
  credentials?: CredentialsOption
  duplex?: DuplexOption
  agent: Agent
}

export interface Header {
  name: string
  value: string
  sensitive?: boolean
}

export declare const enum Http3Congestion {
  Cubic = 'cubic',
  Bbr1 = 'bbr1'
}

export declare const enum Redirect {
  Follow = 'follow',
  Error = 'error',
  Manual = 'manual',
  Stop = 'stop'
}

export const REQWEST_VERSION: string

export const USER_AGENT: string
